# Knuth-Morris-Pratt 算法

> Knuth-Morris-Pratt 算法，简称 KMP 算法，由 Donald Knuth、James H. Morris 和 Vaughan Pratt 三人于 19771977 年联合发表。
>

## 思路及算法

`Knuth-Morris-Pratt` 算法的核心为前缀函数，记作`π(i)`，其定义如下：

对于长度为 `m` 的字符串 `s`，其前缀函数 `π(i)(0≤i<m)` 表示 ss 的子串`s[0:i]` 的最长的相等的真前缀与真后缀的长度。特别地，如果不存在符合条件的前后缀，那么`π(i)=0`。其中真前缀与真后缀的定义为不等于自身的的前缀与后缀。

我们举个例子说明：字符串 `aabaaab` 的前缀函数值依次为 `0,1,0,1,2,2,3`。

- `π(0)=0`，因为 `a` 没有真前缀和真后缀，根据规定为` 0`（可以发现对于任意字符串 `π(0)=0` 必定成立）；

- `π(1)=1`，因为 `aa` 最长的一对相等的真前后缀为 `a`，长度为 `1`；

- `π(2)=0`，因为 `aab` 没有对应真前缀和真后缀，根据规定为 `0`；

- `π(3)=1`，因为 `aaba` 最长的一对相等的真前后缀为 `aa`，长度为 `1`；

- `π(4)=2`，因为 `aabaa` 最长的一对相等的真前后缀为 `aa`，长度为 `2`；

- `π(5)=2`，因为 `aabaaa` 最长的一对相等的真前后缀为 `aa`，长度为 `2`；

- `π(6)=3`，因为 `aabaaab` 最长的一对相等的真前后缀为`aab`，长度为 `3`。

有了前缀函数，我们就可以快速地计算出模式串在主串中的每一次出现。

## 如何求解前缀函数

长度为 `m` 的字符串 `s` 的所有前缀函数的求解算法的总时间复杂度是严格 `O(m)` 的，且该求解算法是增量算法，即我们可以一边读入字符串，一边求解当前读入位的前缀函数。

为了叙述方便，我们接下来将说明几个前缀函数的性质：

- `π(i)≤π(i−1)+1`
  - 依据`π(i)` 定义得：`s[0:π(i)−1]=s[i−π(i)+1:i]`
  - 将两区间的右端点同时左移，可得：`s[0:π(i)−2]=s[i−π(i)+1:i−1]`
  - 依据`π(i−1) `定义得：`π(i−1)≥π(i)−1`，即 `π(i)≤π(i−1)+1`


- 如果`s[i]=s[π(i−1)]`，那么 `π(i)=π(i−1)+1`

